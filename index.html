<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analisador Avançado de POIs com Mapa</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    
    <!-- Leaflet.js para o mapa -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Leaflet.markercluster para agrupar marcadores -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <!-- SheetJS (xlsx) para ler arquivos Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- Fontes do Google -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Inter', sans-serif; }
        #map {
            height: calc(100vh - 150px); /* Altura dinâmica */
            min-height: 600px;
            width: 100%;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .group-card, .metric-value, .lang-flag {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .group-card:hover {
            background-color: #f9fafb; /* gray-50 */
        }
        .dark .group-card:hover {
             background-color: #374151; /* gray-700 */
        }
        .metric-value:hover {
            text-decoration: underline;
        }
        .lang-flag:hover {
            transform: scale(1.1);
        }
        .lang-flag.active {
            box-shadow: 0 0 0 2px #3b82f6; /* Anel azul para a bandeira ativa */
        }
        details > summary {
            list-style: none;
        }
        details > summary::-webkit-details-marker {
            display: none;
        }
        /* Estilos para a tabela de resultados */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 0.5rem;
        }
        .results-table th, .results-table td {
            border: 1px solid #e5e7eb;
            padding: 0.5rem;
            text-align: left;
            font-size: 0.875rem;
        }
        .dark .results-table th, .dark .results-table td {
            border-color: #4b5563;
        }
        .results-table th {
            background-color: #f9fafb;
        }
        .dark .results-table th {
             background-color: #374151;
        }
        #speed-indicator, #rabbit-icon, #turtle-icon {
            transition: all 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 font-sans p-4 md:p-8">

    <div class="max-w-screen-2xl mx-auto">
        <header class="text-center mb-8 break-words">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800 dark:text-gray-100" data-lang="main_title">Analisador Avançado de Pontos de Interesse (POIs)</h1>
            <p class="text-gray-600 dark:text-gray-400 mt-2" data-lang="main_subtitle">Carregue um arquivo para validar, analisar sobreposições e visualizar POIs num mapa interativo.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-5 gap-8">
            <!-- Coluna de Controlo e Resultados -->
            <div class="lg:col-span-2 bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg h-fit max-h-[calc(100vh-100px)] overflow-y-auto">
                <!-- Controles -->
                <div class="border-b dark:border-gray-700 pb-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-semibold text-gray-700 dark:text-gray-200" data-lang="control_title">Controle</h2>
                        <div class="flex space-x-3 items-center">
                            <!-- Bandeiras SVG embutidas -->
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 700" class="lang-flag h-6 w-8 rounded-sm active" data-lang-code="pt" title="Português">
                                <rect width="1000" height="700" fill="#009c3b"/>
                                <path d="M500 80L920 350 500 620 80 350z" fill="#ffdf00"/>
                                <circle cx="500" cy="350" r="175" fill="#002776"/>
                            </svg>
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 750 500" class="lang-flag h-6 w-8 rounded-sm" data-lang-code="es" title="Español">
                                <rect width="750" height="500" fill="#c60b1e"/>
                                <rect y="125" width="750" height="250" fill="#ffc400"/>
                            </svg>
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 30" class="lang-flag h-6 w-8 rounded-sm" data-lang-code="en" title="English">
                                <clipPath id="uk-a"><path d="M0 0v30h60V0z"/></clipPath>
                                <path d="M0 0v30h60V0z" fill="#012169"/>
                                <g clip-path="url(#uk-a)">
                                    <path d="M0 0l60 30m0-30L0 30" stroke="#fff" stroke-width="6"/>
                                    <path d="M0 0l60 30m0-30L0 30" stroke="#C8102E" stroke-width="4"/>
                                    <path d="M30 0v30M0 15h60" stroke="#fff" stroke-width="10"/>
                                    <path d="M30 0v30M0 15h60" stroke="#C8102E" stroke-width="6"/>
                                </g>
                            </svg>
                            <!-- Theme Toggle -->
                            <button id="theme-toggle" type="button" class="text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-700 rounded-lg text-sm p-2">
                                <svg id="theme-toggle-dark-icon" class="hidden w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg>
                                <svg id="theme-toggle-light-icon" class="hidden w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.707.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 100 2h1z" fill-rule="evenodd" clip-rule="evenodd"></path></svg>
                            </button>
                        </div>
                    </div>
                    <div>
                        <label for="file-input" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" data-lang="select_file">1. Selecione o arquivo (.xlsx, .csv)</label>
                        <input type="file" id="file-input" accept=".csv, .xlsx" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors duration-200 cursor-pointer">
                        <span id="file-name-display" class="block mt-2 text-sm text-gray-600 dark:text-gray-400"></span>
                    </div>

                    <div id="column-mapping-section" class="mt-4 p-4 border dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 hidden">
                        <h3 class="font-semibold text-gray-700 dark:text-gray-200 mb-3" data-lang="column_mapping_title">Mapeamento de Colunas</h3>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="lat-column-select" class="block text-xs font-medium text-gray-600 dark:text-gray-300" data-lang="latitude_column">Latitude</label>
                                <select id="lat-column-select" class="mt-1 block w-full p-2 border border-gray-300 dark:border-gray-500 rounded-md shadow-sm text-sm dark:bg-gray-800 dark:text-gray-300"></select>
                            </div>
                            <div>
                                <label for="lon-column-select" class="block text-xs font-medium text-gray-600 dark:text-gray-300" data-lang="longitude_column">Longitude</label>
                                <select id="lon-column-select" class="mt-1 block w-full p-2 border border-gray-300 dark:border-gray-500 rounded-md shadow-sm text-sm dark:bg-gray-800 dark:text-gray-300"></select>
                            </div>
                            <div>
                                <label for="state-column-select" class="block text-xs font-medium text-gray-600 dark:text-gray-300" data-lang="state_column">Estado/UF</label>
                                <select id="state-column-select" class="mt-1 block w-full p-2 border border-gray-300 dark:border-gray-500 rounded-md shadow-sm text-sm dark:bg-gray-800 dark:text-gray-300"></select>
                            </div>
                             <div>
                                <label for="city-column-select" class="block text-xs font-medium text-gray-600 dark:text-gray-300" data-lang="city_column">Cidade/Município</label>
                                <select id="city-column-select" class="mt-1 block w-full p-2 border border-gray-300 dark:border-gray-500 rounded-md shadow-sm text-sm dark:bg-gray-800 dark:text-gray-300"></select>
                            </div>
                        </div>
                    </div>

                     <fieldset id="analysis-options-section" class="mt-4 p-4 border dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 hidden">
                        <legend class="font-semibold text-gray-700 dark:text-gray-200" data-lang="analysis_options_title">Opções de Análise</legend>
                        <div class="mt-2 space-y-2">
                            <label class="flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer">
                                <input type="checkbox" name="analysis_option" value="invalidData" data-cost="5" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 text-blue-600 focus:ring-blue-500 bg-gray-100 dark:bg-gray-900" checked>
                                <span data-lang="option_invalid_data">Verificar dados inválidos</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer">
                                <input type="checkbox" name="analysis_option" value="exactDuplicates" data-cost="10" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 text-blue-600 focus:ring-blue-500 bg-gray-100 dark:bg-gray-900" checked>
                                <span data-lang="option_exact_duplicates">Verificar duplicatas exatas</span>
                            </label>
                            <label class="flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer">
                                <input type="checkbox" name="analysis_option" value="proximity" data-cost="15" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 text-blue-600 focus:ring-blue-500 bg-gray-100 dark:bg-gray-900" checked>
                                <span data-lang="option_proximity">Verificar pontos em proximidade</span>
                            </label>
                             <label class="flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer">
                                <input type="checkbox" name="analysis_option" value="geographic" data-cost="60" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 text-blue-600 focus:ring-blue-500 bg-gray-100 dark:bg-gray-900">
                                <span data-lang="option_geographic">Verificar correspondência geográfica</span>
                            </label>
                            <div class="pt-2 border-t dark:border-gray-600">
                                <label class="flex items-center space-x-2 text-sm font-medium text-gray-700 dark:text-gray-300 cursor-pointer">
                                    <input type="checkbox" id="load-map-checkbox" data-cost="10" name="analysis_option" class="h-4 w-4 rounded border-gray-300 dark:border-gray-600 text-blue-600 focus:ring-blue-500 bg-gray-100 dark:bg-gray-900" checked>
                                    <span data-lang="load_map_points">Carregar pontos no mapa</span>
                                </label>
                            </div>
                        </div>
                        <div class="mt-4">
                            <div class="relative w-full h-8 flex items-center">
                                <span id="rabbit-icon" class="text-2xl transition-opacity duration-300">🐇</span>
                                <div class="w-full h-1 bg-gray-200 dark:bg-gray-600 rounded-full mx-2 relative">
                                    <div id="speed-indicator" class="absolute top-1/2 -translate-y-1/2 h-4 w-4 bg-blue-600 rounded-full border-2 border-white dark:border-gray-800" style="left: 10%;"></div>
                                </div>
                                <span id="turtle-icon" class="text-2xl transition-opacity duration-300">🐢</span>
                            </div>
                             <div class="flex justify-between text-xs font-medium text-gray-500 dark:text-gray-400 px-1">
                                <span data-lang="speed_fast">Rápida</span>
                                <span data-lang="speed_slow">Lenta</span>
                            </div>
                        </div>
                    </fieldset>
                    
                    <div id="exclusion-column-section" class="mt-4 hidden">
                         <label for="exclusion-column-select" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2" data-lang="tie_breaker_column">Coluna para desempate (opcional)</label>
                         <select id="exclusion-column-select" class="block w-full p-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 text-sm">
                             <option value="" data-lang="none_option">Nenhuma</option>
                         </select>
                    </div>

                    <div class="mt-6 flex gap-4">
                         <button id="analyze-btn" class="w-2/3 bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 flex items-center justify-center gap-2 disabled:opacity-50" disabled data-lang="analyze_button">Analisar</button>
                         <button id="clear-btn" class="w-1/3 bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-200 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-500 self-start" data-lang="clear_button">Limpar</button>
                    </div>
                </div>

                <!-- Loader e Mensagens -->
                <div id="loader-container" class="hidden flex-col justify-center items-center my-6">
                    <div class="flex items-center">
                        <div class="loader"></div>
                        <p id="loader-text" class="ml-4 text-gray-600 dark:text-gray-300" data-lang="processing_message">A processar os dados...</p>
                    </div>
                    <button id="cancel-geocoding-btn" class="hidden mt-4 bg-red-500 text-white font-semibold py-1 px-3 rounded-lg hover:bg-red-600 text-sm" data-lang="cancel_geocoding_button">Cancelar</button>
                </div>
                <div id="message-area" class="mt-4"></div>

                <!-- Resultados -->
                <div id="results-section" class="mt-4">
                    <div id="summary-section" class="hidden"></div>
                    <div id="results-header" class="hidden items-center justify-between mb-4 mt-6 flex-wrap gap-4">
                         <h3 class="text-xl font-bold text-gray-800 dark:text-gray-100" data-lang="downloads_title">Downloads</h3>
                         <div class="grid grid-cols-2 gap-2 w-full">
                             <button id="download-full-report-btn" class="bg-green-700 text-white font-semibold py-2 px-3 rounded-lg hover:bg-green-800 text-xs" data-lang="download_full_report_button">Relatório Completo (XLSX)</button>
                             <button id="download-problematic-xlsx-btn" class="bg-red-700 text-white font-semibold py-2 px-3 rounded-lg hover:bg-red-800 text-xs" data-lang="download_problems_button">Problemas (XLSX)</button>
                         </div>
                    </div>
                    <div id="results-output" class="space-y-3 mt-4"></div>
                </div>
            </div>

            <!-- Coluna do Mapa -->
            <div class="lg:col-span-3 bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg">
                 <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold text-gray-700 dark:text-gray-200" data-lang="map_title">Visualização no Mapa</h2>
                    <button id="show-all-btn" class="hidden bg-blue-100 dark:bg-blue-900/50 text-blue-700 dark:text-blue-300 font-semibold py-1 px-3 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-800 text-sm" data-lang="show_all_button">Mostrar Todos</button>
                 </div>
                 <div id="map-container">
                    <div id="map"></div>
                 </div>
            </div>
        </main>
    </div>
    
    <script id="worker-script" type="javascript/worker">
        // --- LÓGICA DO WEB WORKER ---
        importScripts('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');

        const stateMap = {
            'AC': 'Acre', 'AL': 'Alagoas', 'AP': 'Amapá', 'AM': 'Amazonas', 'BA': 'Bahia',
            'CE': 'Ceará', 'DF': 'Distrito Federal', 'ES': 'Espírito Santo', 'GO': 'Goiás',
            'MA': 'Maranhão', 'MT': 'Mato Grosso', 'MS': 'Mato Grosso do Sul', 'MG': 'Minas Gerais',
            'PA': 'Pará', 'PB': 'Paraíba', 'PR': 'Paraná', 'PE': 'Pernambuco', 'PI': 'Piauí',
            'RJ': 'Rio de Janeiro', 'RN': 'Rio Grande do Norte', 'RS': 'Rio Grande do Sul',
            'RO': 'Rondônia', 'RR': 'Roraima', 'SC': 'Santa Catarina', 'SP': 'São Paulo',
            'SE': 'Sergipe', 'TO': 'Tocantins'
        };

        function roundHalfToEven(value) {
            const floor = Math.floor(value);
            const decimal = value - floor;
            if (decimal !== 0.5) return Math.round(value);
            return floor % 2 === 0 ? floor : Math.ceil(value);
        }
        
        async function getReverseGeocode(lat, lon) {
            const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&accept-language=en`;
            try {
                const response = await fetch(url);
                if (!response.ok) return { state: null, city: null };
                const data = await response.json();
                return {
                    state: data?.address?.state,
                    city: data?.address?.city || data?.address?.town || data?.address?.village
                };
            } catch (error) {
                console.error("Geocoding error:", error);
                return { state: null, city: null };
            }
        }
        
        function processParsedData(jsonData, mappedHeaders) {
            if (jsonData.length === 0) return { headers: [], rows: [] };
            const headers = Object.keys(jsonData[0]);
            
            const latHeader = mappedHeaders.lat;
            const lonHeader = mappedHeaders.lon;
            const stateHeader = mappedHeaders.state;
            const cityHeader = mappedHeaders.city;
            
            if (!latHeader || !lonHeader) throw new Error('Colunas de Latitude e Longitude devem ser mapeadas.');
            
            const rows = jsonData.map((row, index) => {
                const latStr = String(row[latHeader] || '').replace(',', '.');
                const lonStr = String(row[lonHeader] || '').replace(',', '.');
                
                let latitude = null;
                let longitude = null;
                let status = null;

                const isLatNumeric = !isNaN(parseFloat(latStr)) && isFinite(latStr);
                const isLonNumeric = !isNaN(parseFloat(lonStr)) && isFinite(lonStr);

                if(latStr && isLatNumeric){
                    latitude = parseFloat(latStr);
                }
                 if(lonStr && isLonNumeric){
                    longitude = parseFloat(lonStr);
                }

                return {
                    row: index + 2,
                    latitude: latitude,
                    longitude: longitude,
                    data: row,
                    status: status
                };
            });
            return { headers, rows, stateHeader, cityHeader };
        }


        self.onmessage = async (event) => {
            const { fileContent, fileType, exclusionColumn, analysisOptions, loadMapPoints, mappedHeaders } = event.data;
            let isGeocodingCancelled = false;
            
            self.onmessage = (e) => {
                if (e.data.action === 'cancel') isGeocodingCancelled = true;
            };

            // 1. PARSING
            self.postMessage({ type: 'progress', payload: { stage: 'parsing' } });
            let jsonData;
            try {
                if (fileType === 'xlsx') {
                    const workbook = XLSX.read(fileContent, { type: 'buffer' });
                    jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]], { defval: "" });
                } else {
                     const lines = fileContent.trim().split(/\r\n|\n/);
                    if (lines.length < 1) throw new Error('CSV vazio.');
                    const delimiter = (lines[0].match(/;/g) || []).length > (lines[0].match(/,/g) || []).length ? ';' : ',';
                    const headers = lines[0].split(delimiter).map(h => h.trim());
                    jsonData = lines.slice(1).map(line => {
                        const values = line.split(delimiter);
                        return headers.reduce((obj, header, i) => {
                            obj[header] = values[i] ? values[i].trim() : "";
                            return obj;
                        }, {});
                    });
                }
            } catch (e) {
                self.postMessage({ type: 'error', payload: e.message });
                return;
            }

            const { rows, headers, stateHeader, cityHeader } = processParsedData(jsonData, mappedHeaders);
            
            // 2. ANÁLISE
            const pointsToAnalyze = [...rows];
            const invalidDataPoints = [];
            
            if (analysisOptions.invalidData) {
                for(let i = pointsToAnalyze.length - 1; i >= 0; i--) {
                    const p = pointsToAnalyze[i];
                    const latStr = String(p.data[mappedHeaders.lat] || '').trim();
                    const lonStr = String(p.data[mappedHeaders.lon] || '').trim();
                    const stateStr = String(p.data[mappedHeaders.state] || '').trim();
                    const cityStr = String(p.data[mappedHeaders.city] || '').trim();

                    const isLatNumeric = !isNaN(parseFloat(latStr.replace(',', '.'))) && isFinite(latStr.replace(',', '.'));
                    const isLonNumeric = !isNaN(parseFloat(lonStr.replace(',', '.'))) && isFinite(lonStr.replace(',', '.'));

                    if (!isLatNumeric || !isLonNumeric) {
                        p.status = { type: 'invalid', reason: 'Formato de Coordenada Inválido' };
                        invalidDataPoints.push(...pointsToAnalyze.splice(i, 1));
                    } else if (analysisOptions.geographic && (!stateStr || !cityStr)) {
                         p.status = { type: 'invalid', reason: 'Cidade/Estado Ausente' };
                         invalidDataPoints.push(...pointsToAnalyze.splice(i, 1));
                    }
                }
            }
            
            const cleanPointsForExport = [];
            const proximityGroups = [];
            const exactDuplicateGroups = [];
            const stateMismatches = [];
            const cityMismatches = [];
            
            if (analysisOptions.geographic) {
                if (!stateHeader || !cityHeader) {
                    self.postMessage({ type: 'error', payload: 'Para a Análise Geográfica, as colunas de Estado e Cidade devem ser mapeadas.' });
                    return;
                }
                let geocodedCount = 0;
                for (const point of pointsToAnalyze) {
                    if (isGeocodingCancelled) break;
                    const location = await getReverseGeocode(point.latitude, point.longitude);
                    point.detectedState = location.state;
                    point.detectedCity = location.city;
                    
                    const providedState = (point.data[stateHeader] || '').trim();
                    const detectedState = (location.state || '').trim();
                    
                    point.stateMatch = providedState.toLowerCase() === detectedState.toLowerCase() ||
                                       (stateMap[providedState.toUpperCase()] && stateMap[providedState.toUpperCase()].toLowerCase() === detectedState.toLowerCase());

                    point.cityMatch = (point.data[cityHeader] || '').trim().toLowerCase() === (location.city || '').trim().toLowerCase();

                    if (!point.stateMatch) {
                        point.status = { type: 'location', reason: 'Estado Incorreto' };
                        stateMismatches.push(point);
                    } else if (!point.cityMatch) {
                        point.status = { type: 'location', reason: 'Cidade Incorreta' };
                        cityMismatches.push(point);
                    } else {
                        point.status = { type: 'clean', reason: 'Ponto Válido' };
                        cleanPointsForExport.push(point);
                    }

                    geocodedCount++;
                    self.postMessage({ type: 'progress', payload: { stage: 'geocoding', current: geocodedCount, total: pointsToAnalyze.length } });
                    if(geocodedCount % 10 === 0) await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            if (analysisOptions.exactDuplicates || analysisOptions.proximity) {
                const meterSquareGroups = new Map();
                const resolution = 0.00001;
                pointsToAnalyze.forEach(point => {
                    const latRounded = roundHalfToEven(point.latitude / resolution);
                    const lonRounded = roundHalfToEven(point.longitude / resolution);
                    const key = `${latRounded},${lonRounded}`;
                    if (!meterSquareGroups.has(key)) meterSquareGroups.set(key, []);
                    meterSquareGroups.get(key).push(point);
                });

                const totalGroups = meterSquareGroups.size;
                let processedGroups = 0;

                meterSquareGroups.forEach(group => {
                    processedGroups++;
                    if (processedGroups % 500 === 0 || processedGroups === totalGroups) {
                         self.postMessage({ type: 'progress', payload: { stage: 'analysis', current: processedGroups, total: totalGroups } });
                    }

                    const subgroups = new Map();
                    group.forEach(p => {
                        const key = exclusionColumn ? `${p.latitude},${p.longitude},${p.data[exclusionColumn]}` : `${p.latitude},${p.longitude}`;
                        if (!subgroups.has(key)) subgroups.set(key, []);
                        subgroups.get(key).push(p);
                    });

                    if (group.length === 1) {
                        const point = group[0];
                        if (!point.status) { // Only mark as clean if no other error was found
                           point.status = { type: 'clean', reason: 'Ponto Válido' };
                           cleanPointsForExport.push(point);
                        }
                    } else {
                        if (subgroups.size > 1 && analysisOptions.proximity) {
                            proximityGroups.push(group);
                        } else if (subgroups.size === 1 && analysisOptions.exactDuplicates) {
                            exactDuplicateGroups.push(group);
                        }
                        
                        subgroups.forEach(subgroup => {
                            let problemFound = false;
                            if (analysisOptions.geographic) {
                                for(const p of subgroup) {
                                    if (p.status?.type === 'location') problemFound = true;
                                }
                            }

                            if(!problemFound) {
                                if (subgroups.size > 1) {
                                    subgroup.forEach(p => p.status = { type: 'proximity', reason: 'Proximidade' });
                                } else {
                                    subgroup[0].status = { type: 'duplicate', reason: `Duplicata (${subgroup.length - 1} extra)` };
                                    for (let i = 1; i < subgroup.length; i++) {
                                        subgroup[i].status = { type: 'duplicate', reason: 'Duplicata exata' };
                                    }
                                }
                            }
                            cleanPointsForExport.push(subgroup[0]); 
                        });
                    }
                });
            } else if (!analysisOptions.geographic) {
                 pointsToAnalyze.forEach(p => {
                    p.status = { type: 'clean', reason: 'Ponto Válido' };
                    cleanPointsForExport.push(p);
                 });
            }

            const allProblematicPoints = [...invalidDataPoints, ...proximityGroups.flat(), ...exactDuplicateGroups.flat(), ...stateMismatches, ...cityMismatches];
            
            const summaryPayload = {
                metrics: {
                    totalPois: rows.length,
                    invalidCoordinates: invalidDataPoints.length,
                    poisInProximity: proximityGroups.flat().length,
                    poisInExactOverlap: exactDuplicateGroups.flat().length,
                    stateMismatches: stateMismatches.length,
                    cityMismatches: cityMismatches.length,
                    cleanPointsCount: cleanPointsForExport.length
                },
                proximityGroups,
                exactDuplicateGroups,
                invalidCoordinatePoints: invalidDataPoints,
                stateMismatches,
                cityMismatches,
                originalData: { headers, stateHeader, cityHeader }
            };

            self.postMessage({ type: 'result-summary', payload: summaryPayload });
            
            if (loadMapPoints) {
                const allPointsForMap = [...cleanPointsForExport, ...allProblematicPoints];
                const CHUNK_SIZE = 10000;
                for (let i = 0; i < allPointsForMap.length; i += CHUNK_SIZE) {
                    const chunk = allPointsForMap.slice(i, i + CHUNK_SIZE);
                    self.postMessage({ type: 'map-data-chunk', payload: chunk });
                    await new Promise(resolve => setTimeout(resolve, 10)); 
                }
            }

            self.postMessage({ type: 'full-data-for-download', payload: { cleanPointsForExport, allProblematicPoints } });

            self.postMessage({ type: 'done' });
        };
    </script>

    <script>
        // --- ELEMENTOS DA UI ---
        const fileInput = document.getElementById('file-input');
        const fileNameDisplay = document.getElementById('file-name-display');
        const analyzeBtn = document.getElementById('analyze-btn');
        const clearBtn = document.getElementById('clear-btn');
        const exclusionColumnSelect = document.getElementById('exclusion-column-select');
        const exclusionColumnSection = document.getElementById('exclusion-column-section');
        const columnMappingSection = document.getElementById('column-mapping-section');
        const latColumnSelect = document.getElementById('lat-column-select');
        const lonColumnSelect = document.getElementById('lon-column-select');
        const stateColumnSelect = document.getElementById('state-column-select');
        const cityColumnSelect = document.getElementById('city-column-select');
        const loader = document.getElementById('loader-container');
        const loaderText = document.getElementById('loader-text');
        const cancelGeocodingBtn = document.getElementById('cancel-geocoding-btn');
        const messageArea = document.getElementById('message-area');
        const summarySection = document.getElementById('summary-section');
        const resultsHeader = document.getElementById('results-header');
        const resultsOutput = document.getElementById('results-output');
        const downloadProblematicXlsxBtn = document.getElementById('download-problematic-xlsx-btn');
        const downloadFullReportBtn = document.getElementById('download-full-report-btn');
        const showAllBtn = document.getElementById('show-all-btn');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const themeToggleDarkIcon = document.getElementById('theme-toggle-dark-icon');
        const themeToggleLightIcon = document.getElementById('theme-toggle-light-icon');
        const analysisOptionsCheckboxes = document.querySelectorAll('#analysis-options-section input[type="checkbox"]');
        const speedIndicator = document.getElementById('speed-indicator');
        const rabbitIcon = document.getElementById('rabbit-icon');
        const turtleIcon = document.getElementById('turtle-icon');

        // --- ESTADO DA APLICAÇÃO ---
        let originalData = { headers: [] };
        let allProblematicPoints = [];
        let cleanPointsForExport = [];
        let proximityGroups = [];
        let exactDuplicateGroups = [];
        let stateMismatches = [];
        let cityMismatches = [];
        let invalidDataPoints = [];
        let allPointsForMap_main = []; // Para filtragem
        let mapDataQueue = [];
        let isProcessingMapQueue = false;
        let isWorkerDone = false;
        let map = null;
        let lightTiles, darkTiles;
        let markerClusterGroup = null;
        let currentFeatureGroup = null;
        let analysisWorker = null;
        let currentLang = 'pt';
        let totalPointsToLoad = 0;
        let totalPointsLoaded = 0;
        let shouldLoadMapPoints = true;

        // --- ÍCONES DO MAPA ---
        const createIcon = (color) => new L.Icon({
            iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${color}.png`,
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
        });
        const icons = {
            clean: createIcon('blue'),
            duplicate: createIcon('red'),
            proximity: createIcon('yellow'),
            invalid: createIcon('black'),
            location: createIcon('violet')
        };

        // --- TRADUÇÕES ---
        const translations = {
            pt: {
                main_title: "Analisador Avançado de Pontos de Interesse (POIs)",
                main_subtitle: "Carregue um arquivo para validar, analisar sobreposições e visualizar POIs num mapa interativo.",
                control_title: "Controle",
                select_file: "1. Selecione o arquivo (.xlsx, .csv)",
                column_mapping_title: "Mapeamento de Colunas",
                latitude_column: "Latitude",
                longitude_column: "Longitude",
                state_column: "Estado/UF",
                city_column: "Cidade/Município",
                tie_breaker_column: "Coluna para desempate (opcional)",
                none_option: "Nenhuma",
                load_map_points: "Carregar pontos no mapa",
                 load_map_points_note: "(indicado desabilitar para bases muito grandes)",
                analyze_button: "Analisar",
                clear_button: "Limpar",
                analysis_options_title: "Opções de Análise",
                option_invalid_data: "Verificar dados inválidos",
                option_exact_duplicates: "Verificar duplicatas exatas",
                option_proximity: "Verificar pontos em proximidade",
                option_geographic: "Verificar correspondência geográfica",
                speed_fast: "Rápida",
                speed_slow: "Lenta",
                processing_message: "A processar os dados...",
                parsing_message: "A ler o ficheiro...",
                analyzing_message: (current, total) => `Analisando: ${Math.round((current/total)*100)}%`,
                geocoding_message: (current, total) => `Geocodificando: ${current} / ${total}`,
                map_loading_message: (current, total) => `A carregar pontos: ${current} / ${total}`,
                cancel_geocoding_button: "Cancelar",
                downloads_title: "Downloads",
                download_full_report_button: "Relatório Completo (XLSX)",
                download_problems_button: "Problemas (XLSX)",
                map_title: "Visualização no Mapa",
                show_all_button: "Mostrar Todos",
                summary_title: "Métricas de Validação",
                total_pois_label: "Total de POIs analisados:",
                exact_overlap_label: "POIs em sobreposição exata:",
                proximity_label: "Pontos em Proximidade:",
                invalid_coords_label: "Dados Inválidos:",
                removed_points_label: "Pontos removidos da base:",
                clean_points_label: "Pontos na base limpa:",
                state_mismatch_label: "POIs com Estado incorreto:",
                city_mismatch_label: "POIs com Cidade incorreta:",
                error_full_analysis_cols: "Para a Análise Completa, o arquivo deve conter colunas de localização (Estado/UF e Cidade/Município).",
                results_title_proximity: "Células com Pontos em Proximidade (Top 100)",
                results_title_exact: "Grupos de Sobreposição Exata (Top 100)",
                results_title_mismatch: "Inconsistências de Localização",
                results_title_invalid: "Dados Inválidos (Top 100)",
                mismatch_state_header: "Estado Incorreto",
                mismatch_city_header: "Cidade Incorreta",
                group_card_header: (count) => `Grupos com ${count} pontos`,
                group_card_count: (count) => `${count} grupo(s)`,
                group_card_points_in_cell: (count) => `${count} pontos na mesma célula`,
                map_popup_row: "Linha",
                map_popup_status: "Status",
                map_popup_status_clean: "Ponto Válido",
                error_reading_file: "Erro ao ler o arquivo:",
                error_no_data: "Nenhum dado para processar.",
                error_generic: "Ocorreu um erro na análise:",
                success_no_problems: "Análise concluída. Nenhum problema encontrado.",
                download_no_data: "Não há dados para baixar."
            },
            en: {
                main_title: "Advanced Point of Interest (POI) Analyzer",
                main_subtitle: "Upload a file to validate, analyze overlaps, and visualize POIs on an interactive map.",
                control_title: "Control",
                select_file: "1. Select the file (.xlsx, .csv)",
                column_mapping_title: "Column Mapping",
                latitude_column: "Latitude",
                longitude_column: "Longitude",
                state_column: "State/UF",
                city_column: "City/Municipality",
                tie_breaker_column: "Tie-breaker column (optional)",
                none_option: "None",
                load_map_points: "Load points on map",
                load_map_points_note: "(recommended to disable for very large files)",
                analyze_button: "Analyze",
                clear_button: "Clear",
                analysis_options_title: "Analysis Options",
                option_invalid_data: "Check for invalid data",
                option_exact_duplicates: "Check for exact duplicates",
                option_proximity: "Check for proximity points",
                option_geographic: "Check geographic match",
                speed_fast: "Fast",
                speed_slow: "Slow",
                processing_message: "Processing data...",
                parsing_message: "Reading file...",
                analyzing_message: (current, total) => `Analyzing: ${Math.round((current/total)*100)}%`,
                geocoding_message: (current, total) => `Geocoding: ${current} / ${total}`,
                map_loading_message: (current, total) => `Loading points: ${current} / ${total}`,
                cancel_geocoding_button: "Cancel",
                downloads_title: "Downloads",
                download_full_report_button: "Full Report (XLSX)",
                download_problems_button: "Problems (XLSX)",
                map_title: "Map Visualization",
                show_all_button: "Show All",
                summary_title: "Validation Metrics",
                total_pois_label: "Total POIs analyzed:",
                exact_overlap_label: "POIs in exact overlap:",
                proximity_label: "Points in Proximity:",
                invalid_coords_label: "Invalid Data:",
                removed_points_label: "Points removed from base:",
                clean_points_label: "Points in clean base:",
                state_mismatch_label: "POIs with incorrect State:",
                city_mismatch_label: "POIs with incorrect City:",
                error_full_analysis_cols: "For Full Analysis, the file must contain location columns (State/UF and City/Município).",
                results_title_proximity: "Cells with Proximity Points (Top 100)",
                results_title_exact: "Exact Overlap Groups (Top 100)",
                results_title_mismatch: "Location Mismatches",
                results_title_invalid: "Invalid Data (Top 100)",
                mismatch_state_header: "Incorrect State",
                mismatch_city_header: "Incorrect City",
                group_card_header: (count) => `Groups with ${count} points`,
                group_card_count: (count) => `${count} group(s)`,
                group_card_points_in_cell: (count) => `${count} points in the same cell`,
                map_popup_row: "Row",
                map_popup_status: "Status",
                map_popup_status_clean: "Valid Point",
                error_reading_file: "Error reading file:",
                error_no_data: "No data to process.",
                error_generic: "An error occurred during analysis:",
                success_no_problems: "Analysis complete. No issues found.",
                download_no_data: "No data to download."
            },
            es: {
                main_title: "Analizador Avanzado de Puntos de Interés (POI)",
                main_subtitle: "Cargue un archivo para validar, analizar superposiciones y visualizar POI en un mapa interactivo.",
                control_title: "Control",
                select_file: "1. Seleccione el archivo (.xlsx, .csv)",
                column_mapping_title: "Mapeo de Columnas",
                latitude_column: "Latitud",
                longitude_column: "Longitud",
                state_column: "Estado/UF",
                city_column: "Ciudad/Municipio",
                tie_breaker_column: "Columna de desempate (opcional)",
                none_option: "Ninguna",
                load_map_points: "Cargar puntos en el mapa",
                load_map_points_note: "(se recomienda desactivar para bases de datos muy grandes)",
                analyze_button: "Analizar",
                clear_button: "Limpiar",
                analysis_options_title: "Opciones de Análisis",
                option_invalid_data: "Verificar datos inválidos",
                option_exact_duplicates: "Verificar duplicados exactos",
                option_proximity: "Verificar puntos de proximidad",
                option_geographic: "Verificar coincidencia geográfica",
                speed_fast: "Rápida",
                speed_slow: "Lenta",
                processing_message: "Procesando datos...",
                parsing_message: "Leyendo el archivo...",
                analyzing_message: (current, total) => `Analizando: ${Math.round((current/total)*100)}%`,
                geocoding_message: (current, total) => `Geocodificando: ${current} / ${total}`,
                map_loading_message: (current, total) => `Cargando puntos: ${current} / ${total}`,
                cancel_geocoding_button: "Cancelar",
                downloads_title: "Descargas",
                download_full_report_button: "Informe Completo (XLSX)",
                download_problems_button: "Problemas (XLSX)",
                map_title: "Visualización en Mapa",
                show_all_button: "Mostrar Todos",
                summary_title: "Métricas de Validación",
                total_pois_label: "Total de POI analizados:",
                exact_overlap_label: "POI en superposición exacta:",
                proximity_label: "Puntos en Proximidad:",
                invalid_coords_label: "Datos Inválidos:",
                removed_points_label: "Puntos eliminados de la base:",
                clean_points_label: "Puntos en la base limpia:",
                state_mismatch_label: "POI con Estado incorrecto:",
                city_mismatch_label: "POI con Ciudad incorrecta:",
                error_full_analysis_cols: "Para el Análisis Completo, el archivo debe contener columnas de ubicación (Estado/UF y Ciudad/Municipio).",
                results_title_proximity: "Celdas con Puntos en Proximidad (Top 100)",
                results_title_exact: "Grupos de Superposición Exacta (Top 100)",
                results_title_mismatch: "Inconsistencias de Ubicación",
                results_title_invalid: "Datos Inválidos (Top 100)",
                mismatch_state_header: "Estado Incorrecto",
                mismatch_city_header: "Ciudad Incorrecta",
                group_card_header: (count) => `Grupos con ${count} puntos`,
                group_card_count: (count) => `${count} grupo(s)`,
                group_card_points_in_cell: (count) => `${count} puntos en la misma celda`,
                map_popup_row: "Fila",
                map_popup_status: "Estado",
                map_popup_status_clean: "Punto Válido",
                error_reading_file: "Error al leer el archivo:",
                error_no_data: "No hay datos para procesar.",
                error_generic: "Ocurrió un error durante el análisis:",
                success_no_problems: "Análisis completo. No se encontraron problemas.",
                download_no_data: "No hay datos para descargar."
            }
        };

        // --- EVENT LISTENERS ---
        fileInput.addEventListener('change', handleFileSelection);
        analyzeBtn.addEventListener('click', handleFileProcessing);
        clearBtn.addEventListener('click', clearAll);
        cancelGeocodingBtn.addEventListener('click', () => { 
            if(analysisWorker) analysisWorker.postMessage({ action: 'cancel' });
        });
        downloadProblematicXlsxBtn.addEventListener('click', () => downloadXLSX(allProblematicPoints, 'coordenadas_problematicas.xlsx'));
        downloadFullReportBtn.addEventListener('click', () => {
             if (allPointsForMap_main.length === 0) {
                showMessage(translations[currentLang].download_no_data, 'info');
                return;
            }
            downloadXLSX(allPointsForMap_main, 'relatorio_completo.xlsx', true)
        });
        showAllBtn.addEventListener('click', () => {
            displayPointsOnMap(allPointsForMap_main, true);
        });
        document.querySelectorAll('.lang-flag').forEach(flag => {
            flag.addEventListener('click', (e) => setLanguage(e.currentTarget.dataset.langCode));
        });
        analysisOptionsCheckboxes.forEach(cb => cb.addEventListener('change', updateSpeedBar));
        
        // --- FUNÇÕES DE INICIALIZAÇÃO ---
        function initializeMap() {
            if (map) map.remove();
            
            lightTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            });

            darkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
            });

            map = L.map('map', {
                layers: [document.documentElement.classList.contains('dark') ? darkTiles : lightTiles]
            }).setView([-14.235, -51.925], 4);
            
            markerClusterGroup = L.markerClusterGroup();
            map.addLayer(markerClusterGroup);
        }

        window.onload = initializeMap;

        // --- FUNÇÕES PRINCIPAIS DE CONTROLO ---
        async function handleFileSelection() {
            clearAnalysisResults(); 
            if (!fileInput.files.length) {
                fileNameDisplay.textContent = '';
                analyzeBtn.disabled = true;
                columnMappingSection.classList.add('hidden');
                document.getElementById('analysis-options-section').classList.add('hidden');
                return;
            }
            const file = fileInput.files[0];
            fileNameDisplay.textContent = file.name;
            
            try {
                const { headers } = await parseFile(file);
                populateMappingDropdowns(headers);
                populateExclusionDropdown(headers);
                analyzeBtn.disabled = false;
                document.getElementById('analysis-options-section').classList.remove('hidden');
                updateSpeedBar();
            } catch(e) {
                showMessage(translations[currentLang].error_reading_file + ' ' + e.message);
            }
        }

        async function handleFileProcessing() {
            clearAnalysisResults();
            if (!fileInput.files.length) {
                showMessage(translations[currentLang].error_no_data);
                return;
            }

            const analysisOptions = {
                invalidData: document.querySelector('input[value="invalidData"]').checked,
                exactDuplicates: document.querySelector('input[value="exactDuplicates"]').checked,
                proximity: document.querySelector('input[value="proximity"]').checked,
                geographic: document.querySelector('input[value="geographic"]').checked,
            };

            loader.classList.remove('hidden');
            loaderText.textContent = translations[currentLang].processing_message;
            if(analysisOptions.geographic) cancelGeocodingBtn.classList.remove('hidden');
            
            shouldLoadMapPoints = loadMapCheckbox.checked;

            const workerScript = document.getElementById('worker-script').textContent;
            const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
            analysisWorker = new Worker(URL.createObjectURL(workerBlob));

            analysisWorker.onmessage = (e) => {
                const { type, payload } = e.data;

                if (type === 'progress') {
                    const { stage, current, total } = payload;
                    if (stage === 'geocoding') loaderText.textContent = translations[currentLang].geocoding_message(current, total);
                    else if (stage === 'parsing') loaderText.textContent = translations[currentLang].parsing_message;
                    else loaderText.textContent = translations[currentLang].analyzing_message(current, total);
                } else if (type === 'result-summary') {
                    proximityGroups = payload.proximityGroups;
                    exactDuplicateGroups = payload.exactDuplicateGroups;
                    invalidDataPoints = payload.invalidCoordinatePoints;
                    stateMismatches = payload.stateMismatches;
                    cityMismatches = payload.cityMismatches;
                    originalData = payload.originalData;
                    displayResults(payload.metrics, analysisOptions);
                    
                    if (shouldLoadMapPoints) {
                        totalPointsToLoad = payload.metrics.totalPois - payload.metrics.invalidCoordinates;
                        totalPointsLoaded = 0;
                        loaderText.textContent = translations[currentLang].map_loading_message(totalPointsLoaded, totalPointsToLoad);
                        markerClusterGroup.clearLayers();
                        allPointsForMap_main = [];
                        mapDataQueue = [];
                        isProcessingMapQueue = false;
                        isWorkerDone = false;
                    }

                } else if (type === 'map-data-chunk') {
                    if (shouldLoadMapPoints) {
                        mapDataQueue.push(payload);
                        if (!isProcessingMapQueue) {
                            processMapQueue();
                        }
                    }
                } else if (type === 'full-data-for-download') {
                    cleanPointsForExport = payload.cleanPointsForExport;
                    allProblematicPoints = payload.allProblematicPoints;
                } else if (type === 'done') {
                    if(shouldLoadMapPoints) {
                        isWorkerDone = true;
                        if (!isProcessingMapQueue) {
                            processMapQueue();
                        }
                    } else {
                        loader.classList.add('hidden');
                        cancelGeocodingBtn.classList.add('hidden');
                        if (analysisWorker) analysisWorker.terminate();
                    }
                } else if (type === 'error') {
                    showMessage(translations[currentLang].error_generic + ' ' + payload);
                    loader.classList.add('hidden');
                    cancelGeocodingBtn.classList.add('hidden');
                    if(analysisWorker) analysisWorker.terminate();
                }
            };

            analysisWorker.onerror = (e) => {
                showMessage(translations[currentLang].error_generic + ' ' + e.message);
                loader.classList.add('hidden');
                cancelGeocodingBtn.classList.add('hidden');
                if(analysisWorker) analysisWorker.terminate();
            };

            const file = fileInput.files[0];
            const fileType = file.name.toLowerCase().endsWith('.xlsx') ? 'xlsx' : 'csv';
            const reader = new FileReader();
            reader.onload = (e) => {
                analysisWorker.postMessage({
                    fileContent: e.target.result,
                    fileType,
                    exclusionColumn: exclusionColumnSelect.value,
                    analysisOptions,
                    loadMapPoints: shouldLoadMapPoints,
                    mappedHeaders: {
                        lat: latColumnSelect.value,
                        lon: lonColumnSelect.value,
                        state: stateColumnSelect.value,
                        city: cityColumnSelect.value,
                    }
                }, [e.target.result]);
            };
            
            reader.readAsArrayBuffer(file);
        }

        async function processMapQueue() {
            if (isProcessingMapQueue) return;
            isProcessingMapQueue = true;

            const UI_CHUNK_SIZE = 500; // Process smaller chunks on the main thread

            while (mapDataQueue.length > 0 || !isWorkerDone) {
                if (mapDataQueue.length > 0) {
                    const chunk = mapDataQueue.shift();
                    allPointsForMap_main.push(...chunk);
                    
                    for (let i = 0; i < chunk.length; i += UI_CHUNK_SIZE) {
                        const uiChunk = chunk.slice(i, i + UI_CHUNK_SIZE);
                        addPointsToMap(uiChunk);
                        totalPointsLoaded += uiChunk.length;
                        loaderText.textContent = translations[currentLang].map_loading_message(totalPointsLoaded, totalPointsToLoad);
                        
                        // Yield to the main thread to prevent freezing
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                } else {
                    // Wait for more data if worker is not done yet
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            }

            // Finalize when the worker is done and the queue is empty
            if (markerClusterGroup.getLayers().length > 0) {
                map.fitBounds(markerClusterGroup.getBounds(), { padding: [50, 50], maxZoom: 18 });
            }
            loader.classList.add('hidden');
            cancelGeocodingBtn.classList.add('hidden');
            if (analysisWorker) {
                analysisWorker.terminate();
                analysisWorker = null;
            }
            isProcessingMapQueue = false;
        }
        
        function addPointsToMap(points) {
            if (!points || points.length === 0) return;
            const markers = points.map(poi => {
                if(poi.latitude === null || poi.longitude === null) return null;
                const icon = icons[poi.status.type] || icons.duplicate;
                const marker = L.marker([poi.latitude, poi.longitude], { icon: icon });
                marker.bindPopup(`<b>${translations[currentLang].map_popup_row}:</b> ${poi.row}<br><b>Lat:</b> ${poi.latitude}<br><b>Lon:</b> ${poi.longitude}<br><b>${translations[currentLang].map_popup_status}:</b> ${poi.status.reason}`);
                return marker;
            }).filter(Boolean);
            if(markers.length > 0) markerClusterGroup.addLayers(markers);
        }

        // --- FUNÇÕES DE EXIBIÇÃO E UI ---
        function displayResults(metrics, analysisOptions) {
            const pontosRemovidos = metrics.totalPois - metrics.cleanPointsCount;
            const pontosRestantes = metrics.cleanPointsCount;

            let metricsHtml = `
                <div class="flex justify-between items-center ${!analysisOptions.invalidData ? 'hidden' : ''}">
                    <span class="font-medium" data-lang="invalid_coords_label"></span>
                    <span class="font-bold text-lg text-black dark:text-gray-300">${metrics.invalidCoordinates.toLocaleString('pt-BR')}</span>
                </div>
                <div class="flex justify-between items-center ${!analysisOptions.proximity ? 'hidden' : ''}">
                    <span class="font-medium" data-lang="proximity_label"></span>
                    <span id="metric-proximity" class="metric-value font-bold text-lg text-yellow-500">${metrics.poisInProximity.toLocaleString('pt-BR')}</span>
                </div>
                <div class="flex justify-between items-center ${!analysisOptions.exactDuplicates ? 'hidden' : ''}">
                    <span class="font-medium" data-lang="exact_overlap_label"></span>
                    <span id="metric-overlap" class="metric-value font-bold text-lg text-red-600">${metrics.poisInExactOverlap.toLocaleString('pt-BR')}</span>
                </div>
                <div class="flex justify-between items-center ${!analysisOptions.geographic ? 'hidden' : ''}">
                    <span class="font-medium" data-lang="state_mismatch_label"></span>
                    <span id="metric-state-mismatch" class="metric-value font-bold text-lg text-purple-600">${metrics.stateMismatches}</span>
                </div>
                <div class="flex justify-between items-center ${!analysisOptions.geographic ? 'hidden' : ''}">
                    <span class="font-medium" data-lang="city_mismatch_label"></span>
                    <span id="metric-city-mismatch" class="metric-value font-bold text-lg text-purple-600">${metrics.cityMismatches}</span>
                </div>
            `;
            
            summarySection.innerHTML = `
                <h3 class="font-bold text-lg text-gray-800 dark:text-gray-100 mb-3" data-lang="summary_title"></h3>
                <div class="space-y-3 text-gray-600 dark:text-gray-300 bg-blue-50 dark:bg-gray-700/50 border border-blue-200 dark:border-blue-800 p-4 rounded-lg">
                    <div class="flex justify-between items-center">
                        <span class="font-medium" data-lang="total_pois_label"></span>
                        <span id="metric-total" class="metric-value font-bold text-lg text-gray-800 dark:text-gray-100">${metrics.totalPois.toLocaleString('pt-BR')}</span>
                    </div>
                    ${metricsHtml}
                    <div class="flex justify-between items-center pt-2 border-t dark:border-gray-600 mt-2">
                        <span class="font-medium" data-lang="removed_points_label"></span>
                        <span id="metric-removed" class="metric-value font-bold text-lg text-orange-500">${pontosRemovidos.toLocaleString('pt-BR')}</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="font-medium" data-lang="clean_points_label"></span>
                        <span id="metric-clean" class="metric-value font-bold text-lg text-green-600">${pontosRestantes.toLocaleString('pt-BR')}</span>
                    </div>
                </div>`;
            summarySection.classList.remove('hidden');

            const LIMIT = 100;
            if (invalidDataPoints.length + proximityGroups.length + exactDuplicateGroups.length + stateMismatches.length + cityMismatches.length > 0) {
                resultsHeader.classList.remove('hidden');
                if (shouldLoadMapPoints) showAllBtn.classList.remove('hidden');
                let resultsHtml = '';

                if (invalidDataPoints.length > 0) {
                    resultsHtml += `<h4 class="font-semibold text-md text-gray-700 dark:text-gray-200 mt-4 mb-2" data-lang="results_title_invalid"></h4>`;
                    resultsHtml += createCollapsibleSection(invalidDataPoints.slice(0, LIMIT).map(p => [p]), 'invalid');
                }
                
                if (stateMismatches.length > 0 || cityMismatches.length > 0) {
                     resultsHtml += `<h4 class="font-semibold text-md text-gray-700 dark:text-gray-200 mt-4 mb-2" data-lang="results_title_mismatch"></h4>`;
                     resultsHtml += createMismatchSection(stateMismatches.slice(0, LIMIT), cityMismatches.slice(0, LIMIT));
                }

                if (exactDuplicateGroups.length > 0) {
                    resultsHtml += `<h4 class="font-semibold text-md text-gray-700 dark:text-gray-200 mt-4 mb-2" data-lang="results_title_exact"></h4>`;
                    resultsHtml += createCollapsibleSection(exactDuplicateGroups.slice(0, LIMIT), 'exact');
                }
                if (proximityGroups.length > 0) {
                    resultsHtml += `<h4 class="font-semibold text-md text-gray-700 dark:text-gray-200 mt-4 mb-2" data-lang="results_title_proximity"></h4>`;
                    resultsHtml += createCollapsibleSection(proximityGroups.slice(0, LIMIT), 'proximity');
                }
                
                resultsOutput.innerHTML = resultsHtml;
                document.querySelectorAll('.group-card').forEach(card => card.addEventListener('click', handleGroupCardClick));
            } else {
                showMessage(translations[currentLang].success_no_problems, 'success');
            }
            
            addMetricListeners(stateMismatches, cityMismatches);
            setLanguage(currentLang);
        }

        function createMismatchSection(stateMismatches, cityMismatches) {
            let html = '';
            if (stateMismatches.length > 0) {
                html += `
                    <details class="bg-gray-50 dark:bg-gray-700/50 rounded-lg border dark:border-gray-600 mt-2">
                        <summary class="p-3 font-semibold cursor-pointer flex justify-between items-center text-gray-800 dark:text-gray-100">
                            <span data-lang="mismatch_state_header"></span>
                            <span class="text-sm text-gray-500 dark:text-gray-400">${stateMismatches.length}</span>
                        </summary>
                        <div class="p-2 border-t dark:border-gray-600 text-gray-800 dark:text-gray-300">${createMismatchTable(stateMismatches, 'state')}</div>
                    </details>
                `;
            }
            if (cityMismatches.length > 0) {
                 html += `
                    <details class="bg-gray-50 dark:bg-gray-700/50 rounded-lg border dark:border-gray-600 mt-2">
                        <summary class="p-3 font-semibold cursor-pointer flex justify-between items-center text-gray-800 dark:text-gray-100">
                            <span data-lang="mismatch_city_header"></span>
                            <span class="text-sm text-gray-500 dark:text-gray-400">${cityMismatches.length}</span>
                        </summary>
                        <div class="p-2 border-t dark:border-gray-600 text-gray-800 dark:text-gray-300">${createMismatchTable(cityMismatches, 'city')}</div>
                    </details>
                `;
            }
            return html;
        }

        function createMismatchTable(mismatches, type) {
            const { stateHeader, cityHeader } = originalData;
            let table = '<table class="results-table"><thead><tr><th>Linha</th><th>Informado</th><th>Detectado</th></tr></thead><tbody>';
            mismatches.forEach(p => {
                const informed = type === 'state' ? p.data[stateHeader] : p.data[cityHeader];
                const detected = type === 'state' ? p.detectedState : p.detectedCity;
                table += `<tr><td>${p.row}</td><td>${informed || ''}</td><td>${detected || ''}</td></tr>`;
            });
            table += '</tbody></table>';
            return table;
        }
        
        function createCollapsibleSection(groups, type) {
            const groupsByCount = groups.reduce((acc, group) => {
                const count = group.length;
                if (!acc[count]) acc[count] = [];
                acc[count].push(group);
                return acc;
            }, {});

            const sortedCounts = Object.keys(groupsByCount).sort((a, b) => b - a);
            
            let html = '';
            sortedCounts.forEach(count => {
                const currentGroups = groupsByCount[count];
                html += `
                    <details class="bg-gray-50 dark:bg-gray-700/50 rounded-lg border dark:border-gray-600 mt-2">
                        <summary class="p-3 font-semibold cursor-pointer flex justify-between items-center text-gray-800 dark:text-gray-100">
                            <span data-lang-count-header="${count}"></span>
                            <span class="text-sm text-gray-500 dark:text-gray-400" data-lang-count-groups="${currentGroups.length}"></span>
                        </summary>
                        <div class="p-2 border-t dark:border-gray-600">
                            ${currentGroups.map((group, idx) => {
                                const groupList = type === 'proximity' ? proximityGroups : (type === 'exact' ? exactDuplicateGroups : invalidDataPoints.map(p=>[p]));
                                const originalIndex = groupList.findIndex(g => g === group);
                                return createGroupResultCard(group, originalIndex, type);
                            }).join('')}
                        </div>
                    </details>
                `;
            });
            return html;
        }

        function createGroupResultCard(group, index, type) {
            const pointsHtml = group.map(p => 
                `<li class="flex justify-between items-center text-sm py-1"><span class="font-mono text-gray-700 dark:text-gray-300" data-lang="map_popup_row" data-row-number="${p.row}"></span><span class="text-xs text-gray-500 dark:text-gray-400">${p.latitude !== null ? p.latitude.toFixed(6) : 'N/A'}, ${p.longitude !== null ? p.longitude.toFixed(6) : 'N/A'}</span></li>`
            ).join('');

            return `
                <div class="group-card bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded-lg shadow-sm overflow-hidden mt-2" data-group-index="${index}" data-group-type="${type}">
                    <div class="p-3">
                        <div class="flex justify-between items-center font-semibold text-sm text-gray-800 dark:text-gray-100">
                            <span data-lang-points-in-cell="${group.length}"></span>
                            <span class="text-xs font-mono text-blue-600 dark:text-blue-400" data-lang="view_on_map"></span>
                        </div>
                        <ul class="text-xs mt-2 border-t dark:border-gray-700 pt-2">${pointsHtml}</ul>
                    </div>
                </div>`;
        }
        
        function addMetricListeners(stateMismatches, cityMismatches){
            document.getElementById('metric-total')?.addEventListener('click', () => displayPointsOnMap(allPointsForMap_main, true));
            document.getElementById('metric-proximity')?.addEventListener('click', () => displayPointsOnMap(allPointsForMap_main.filter(p => p.status.type === 'proximity'), true));
            document.getElementById('metric-overlap')?.addEventListener('click', () => displayPointsOnMap(allPointsForMap_main.filter(p => p.status.type === 'duplicate'), true));
            document.getElementById('metric-removed')?.addEventListener('click', () => {
                 const cleanIds = new Set(cleanPointsForExport.map(p => p.row));
                 const removedPoints = allPointsForMap_main.filter(p => !cleanIds.has(p.row));
                 displayPointsOnMap(removedPoints, true);
            });
            document.getElementById('metric-clean')?.addEventListener('click', () => displayPointsOnMap(cleanPointsForExport, true));
            document.getElementById('metric-state-mismatch')?.addEventListener('click', () => displayPointsOnMap(stateMismatches, true));
            document.getElementById('metric-city-mismatch')?.addEventListener('click', () => displayPointsOnMap(cityMismatches, true));
        }

        function handleGroupCardClick(event) {
            const card = event.currentTarget;
            const groupIndex = parseInt(card.dataset.groupIndex, 10);
            const groupType = card.dataset.groupType;
            
            let group;
            if (groupType === 'proximity') group = proximityGroups[groupIndex];
            else if (groupType === 'exact') group = exactDuplicateGroups[groupIndex];
            else if (groupType === 'invalid') group = [invalidDataPoints[groupIndex]];

            if (group) displayPointsOnMap(group, false);
        }

        function displayPointsOnMap(points, cluster = true) {
            if (!shouldLoadMapPoints) return;
            if (currentFeatureGroup) map.removeLayer(currentFeatureGroup);
            currentFeatureGroup = null;
            markerClusterGroup.clearLayers();

            if (!points || points.length === 0) return;

            const markers = points.map(poi => {
                if(poi.latitude === null || poi.longitude === null) return null;
                const icon = icons[poi.status.type] || icons.duplicate;
                const marker = L.marker([poi.latitude, poi.longitude], { icon: icon });
                marker.bindPopup(`<b>${translations[currentLang].map_popup_row}:</b> ${poi.row}<br><b>Lat:</b> ${poi.latitude}<br><b>Lon:</b> ${poi.longitude}<br><b>${translations[currentLang].map_popup_status}:</b> ${poi.status.reason}`);
                return marker;
            }).filter(Boolean);

            if (markers.length === 0) return;

            const featureGroup = L.featureGroup(markers);

            if (cluster) markerClusterGroup.addLayer(featureGroup);
            else {
                currentFeatureGroup = featureGroup;
                map.addLayer(currentFeatureGroup);
            }
            
            map.fitBounds(featureGroup.getBounds(), { padding: [50, 50], maxZoom: 18 });
        }
        
        // --- FUNÇÕES DE UI E UTILITÁRIOS ---
        function setLanguage(lang) {
            currentLang = lang;
            if(document.documentElement.lang.split('-')[0] !== lang) {
                document.documentElement.lang = lang.split('-')[0];
            }
            
            document.querySelectorAll('[data-lang]').forEach(el => {
                const key = el.dataset.lang;
                if (translations[lang] && translations[lang][key] && typeof translations[lang][key] !== 'function') {
                    el.textContent = translations[lang][key];
                }
            });

            document.querySelectorAll('.lang-flag').forEach(flag => {
                flag.classList.toggle('active', flag.dataset.langCode === lang);
            });
        }
        
        function showMessage(text, type = 'error') {
            const colors = { error: 'red', success: 'green', info: 'blue' };
            const darkColors = { error: 'red-900/50', success: 'green-900/50', info: 'blue-900/50' };
            messageArea.innerHTML = `<div class="p-4 border-l-4 border-${colors[type]}-400 dark:border-${colors[type]}-500 bg-${colors[type]}-100 dark:bg-${darkColors[type]} text-${colors[type]}-700 dark:text-${colors[type]}-300 rounded-md" role="alert"><p>${text}</p></div>`;
        }

        function populateMappingDropdowns(headers) {
            const selects = [latColumnSelect, lonColumnSelect, stateColumnSelect, cityColumnSelect];
            selects.forEach(select => {
                select.innerHTML = '<option value="">-</option>';
                 headers.forEach(header => {
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    select.appendChild(option);
                });
            });

            const findAndSet = (select, possibleNames) => {
                 for (const name of possibleNames) {
                    const found = headers.find(h => h.trim().toLowerCase() === name);
                    if (found) {
                        select.value = found;
                        return;
                    }
                }
            };

            findAndSet(latColumnSelect, ['latitude', 'latitude*']);
            findAndSet(lonColumnSelect, ['longitude', 'longitude*']);
            findAndSet(stateColumnSelect, ['estado', 'uf', 'state*']);
            findAndSet(cityColumnSelect, ['cidade', 'município', 'municipio', 'city*']);
            
            columnMappingSection.classList.remove('hidden');
        }
        
        function populateExclusionDropdown(headers) {
            exclusionColumnSelect.innerHTML = `<option value="" data-lang="none_option">${translations[currentLang].none_option}</option>`;
            headers.forEach(header => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                exclusionColumnSelect.appendChild(option);
            });
            exclusionColumnSection.parentElement.classList.remove('hidden');
        }

        function updateSpeedBar() {
            let cost = 0;
            document.querySelectorAll('#analysis-options-section input[type="checkbox"]').forEach(cb => {
                if(cb.checked) {
                    cost += parseInt(cb.dataset.cost, 10);
                }
            });
            
            const position = Math.max(0, Math.min(100, cost));
            speedIndicator.style.left = `calc(${position}% - 8px)`;

            rabbitIcon.style.opacity = 1 - (position / 100) * 0.7;
            turtleIcon.style.opacity = 0.3 + (position / 100) * 0.7;
        }

        function clearAll() {
            fileInput.value = '';
            fileNameDisplay.textContent = '';
            analyzeBtn.disabled = true;
            columnMappingSection.classList.add('hidden');
            document.getElementById('analysis-options-section').classList.add('hidden');
            exclusionColumnSection.classList.add('hidden');
            clearAnalysisResults();
            initializeMap();
        }
        function clearAnalysisResults() {
            resultsOutput.innerHTML = '';
            messageArea.innerHTML = '';
            summarySection.classList.add('hidden');
            resultsHeader.classList.add('hidden');
            showAllBtn.classList.add('hidden');
            allProblematicPoints = [];
            cleanPointsForExport = [];
            proximityGroups = [];
            exactDuplicateGroups = [];
            allPointsForMap_main = [];
        }

        function parseFile(file) { // Apenas para popular o dropdown
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = e.target.result;
                        let headers;
                        if (file.name.toLowerCase().endsWith('.xlsx')) {
                             const workbook = XLSX.read(data, { type: 'buffer', sheetRows: 1 });
                             headers = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]], { header: 1 })[0];
                        } else {
                            const lines = data.trim().split(/\r\n|\n/);
                            if (lines.length < 1) throw new Error('CSV vazio.');
                            const delimiter = (lines[0].match(/;/g) || []).length > (lines[0].match(/,/g) || []).length ? ';' : ',';
                            headers = lines[0].split(delimiter).map(h => h.trim());
                        }
                        resolve({ headers });
                    } catch (err) { reject(err); }
                };
                reader.onerror = () => reject(new Error('Não foi possível ler o arquivo.'));
                if (file.name.toLowerCase().endsWith('.csv')) reader.readAsText(file, 'UTF-8');
                else reader.readAsArrayBuffer(file);
            });
        }
        
        function downloadXLSX(points, fileName, isFullReport = false) {
            if (points.length === 0) {
                showMessage(translations[currentLang].download_no_data, 'info');
                return;
            }
            const dataToExport = points.map(p => {
                const row = { ...p.data };
                if (p.status?.reason) {
                    const statusKey = isFullReport ? 'STATUS_ANALISE' : 'MOTIVO_PROBLEMA';
                    row[statusKey] = p.status.reason;
                    
                    if (p.detectedState !== undefined) row['Estado_Detectado'] = p.detectedState;
                    if (p.detectedCity !== undefined) row['Cidade_Detectada'] = p.detectedCity;
                } else if (isFullReport) {
                    row['STATUS_ANALISE'] = translations[currentLang].map_popup_status_clean;
                }
                return row;
            });
            const worksheet = XLSX.utils.json_to_sheet(dataToExport);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Resultados');
            XLSX.writeFile(workbook, fileName);
        }

        // --- Theme Toggle ---
        if (localStorage.getItem('color-theme') === 'dark' || (!('color-theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }

        function updateThemeIcons() {
             if (document.documentElement.classList.contains('dark')) {
                themeToggleLightIcon.classList.remove('hidden');
                themeToggleDarkIcon.classList.add('hidden');
            } else {
                themeToggleLightIcon.classList.add('hidden');
                themeToggleDarkIcon.classList.remove('hidden');
            }
        }
        updateThemeIcons();

        themeToggleBtn.addEventListener('click', function() {
            document.documentElement.classList.toggle('dark');
            let theme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            localStorage.setItem('color-theme', theme);
            updateThemeIcons();
            if (map) {
                if (theme === 'dark') {
                    if (map.hasLayer(lightTiles)) map.removeLayer(lightTiles);
                    if (!map.hasLayer(darkTiles)) map.addLayer(darkTiles);
                } else {
                    if (map.hasLayer(darkTiles)) map.removeLayer(darkTiles);
                    if (!map.hasLayer(lightTiles)) map.addLayer(lightTiles);
                }
            }
        });
    </script>
</body>
</html>

